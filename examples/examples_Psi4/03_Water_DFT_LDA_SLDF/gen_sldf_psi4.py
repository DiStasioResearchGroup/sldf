import sys
import os
import psi4
import numpy as np

import sldf

psi4.set_memory('1000 MB')

mol = psi4.geometry('''
0 1
H    0.00000000    0.91087015    0.53855853
H    0.00000000   -0.88833620    0.55719192
O    0.00000000    0.00000000    1.29177249
symmetry c1
no_reorient
no_com
''')

psi4.set_options(
        {'basis': 'cc-pVTZ',
         'e_convergence': 1e-12,
         'dft_radial_points': 99,
         'dft_spherical_points': 590
         })

psi4.core.set_output_file('psi4.log')
e, wfn = psi4.energy('SCF', dft_functional='SVWN', return_wfn=True)

D_psi4_mat = wfn.Da()
D = np.array(D_psi4_mat)

# Create a dummy superfunctional object to compute electron density 
# Set its potential based on previously calculated density matrix
# Must be a GGA or above which calculates density gradient
sup = psi4.driver.dft.build_superfunctional('PBE', True)[0]
Vpot = psi4.core.VBase.build(wfn.basisset(), sup, 'RV')
Vpot.initialize()
Vpot.set_D([D_psi4_mat])
Vpot.properties()[0].set_pointers(D_psi4_mat)

points_func = Vpot.properties()[0]

rho = []
dx_rho = []
dy_rho = []
dz_rho = []
weights = []
tau = []

# Reference: psi4numpy/Tutorials/04_Density_Functional_Theory/4c_GGA_and_Meta_GGA.ipynb
# Loop over the blocks
for i in range(Vpot.nblocks()):
    
    # Obtain block information
    block = Vpot.get_block(i)
    points_func.compute_points(block)
    npoints = block.npoints()
    lpos = np.array(block.functions_local_to_global())
    
    # Obtain the grid weight
    w_i = np.array(block.w())

    # Compute phi and derivatives
    phi = np.array(points_func.basis_values()["PHI"])[:npoints, :lpos.shape[0]]

    phi_x = np.array(points_func.basis_values()["PHI_X"])[:npoints, :lpos.shape[0]]
    phi_y = np.array(points_func.basis_values()["PHI_Y"])[:npoints, :lpos.shape[0]]
    phi_z = np.array(points_func.basis_values()["PHI_Z"])[:npoints, :lpos.shape[0]]
    
    # Build a local slice of D
    lD = D[(lpos[:, None], lpos)]
    
    # Copmute rho and derivatives
    rho_i = 2.0 * np.einsum('pm,mn,pn->p', phi, lD, phi, optimize=True)

    dx_rho_i = 4.0 * np.einsum('pm,mn,pn->p', phi, lD, phi_x, optimize=True)
    dy_rho_i = 4.0 * np.einsum('pm,mn,pn->p', phi, lD, phi_y, optimize=True)
    dz_rho_i = 4.0 * np.einsum('pm,mn,pn->p', phi, lD, phi_z, optimize=True)

    # Compute Tau
    tau_i = np.einsum('pm, mn, pn->p', phi_x,lD, phi_x, optimize=True)
    tau_i += np.einsum('pm, mn, pn->p', phi_y,lD, phi_y, optimize=True)
    tau_i += np.einsum('pm, mn, pn->p', phi_z,lD, phi_z, optimize=True)

    # Append
    weights.append(w_i)
    rho.append(rho_i) 
    dx_rho.append(dx_rho_i)
    dy_rho.append(dy_rho_i)
    dz_rho.append(dz_rho_i)
    tau.append(tau_i)

# Electron density and gradients
rho = np.concatenate(rho, axis=0)
dx_rho = np.concatenate(dx_rho, axis=0)
dy_rho = np.concatenate(dy_rho, axis=0)
dz_rho = np.concatenate(dz_rho, axis=0)

s = np.sqrt(dx_rho ** 2 + dy_rho ** 2 + dz_rho ** 2) / (rho ** (4/3))

# Grid weights
weights = np.concatenate(weights, axis=0)

# Kinetic energy density, tau;
# int tau dr = KE
tau = np.concatenate(tau, axis=0)

nsp = 20
sldf = sldf.calc_SLDF(rho, s, weights, nsp)

np.savetxt('sldf.csv', sldf)

print('SLDF is')
print(sldf)

Ex_sldf = np.sum(sldf[:nsp])
Ec_sldf = np.sum(sldf[nsp:])

# Reference SLDF is generated by Psi4 1.3.2;
# Might be slightly different if other versions of Psi4 are used
ref_sldf = np.array([
-2.70295652e-02, -9.14868768e-01, -2.59627541e+00, -2.08742088e+00,
-1.18357925e+00, -7.69743043e-01, -2.34021769e-01, -4.69485602e-02,
-2.81838773e-02, -1.80407285e-02, -1.16750439e-02, -7.76012010e-03,
-5.34641132e-03, -3.81134103e-03, -2.77956167e-03, -2.02963846e-03,
-1.42172980e-03, -8.14942875e-04, -2.20588419e-04, -9.29395826e-06,
-1.08320106e-06, -1.50494513e-05, -4.97301997e-05, -9.16937621e-05,
-1.22285446e-04, -1.88412919e-04, -2.49984636e-04, -3.26307188e-04,
-4.99278308e-04, -1.36039441e-03, -1.02650047e-02, -2.11378362e-02,
-2.10344160e-02, -2.56703414e-02, -3.66003625e-02, -5.22408097e-02,
-6.85151819e-02, -6.09075017e-02, -1.63266598e-02, -6.74170769e-04,
-3.91609011e-04, -2.25514001e-02, -7.59694636e-02, -7.48448850e-02,
-5.41072109e-02, -3.74281461e-02, -3.11676812e-02, -1.86684511e-02,
-6.42647561e-03, -4.04310927e-03, -2.94735257e-03, -2.11247107e-03,
-1.50654005e-03, -1.08922647e-03, -8.07949005e-04, -6.12760977e-04,
-4.62305084e-04, -3.02472693e-04, -9.56375120e-05, -4.60619977e-06
])

if np.allclose(ref_sldf, sldf):
    print('SLDF generation is successful!')
    print('SLDF is saved to sldf.csv')
    print(f'Sum of Exchange SLDF = {Ex_sldf:.3f}')
    print(f'Sum of Correlation SLDF = {Ec_sldf:.3f}')
else:
    print('SLDF generation is not consistent with SLDF generated by Psi4 1.3.2')
    print(f'Mean absolute difference is {np.mean(abs(ref_sldf - sldf)):.2e}')
