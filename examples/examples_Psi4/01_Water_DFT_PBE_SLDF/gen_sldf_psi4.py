import sys
import os
import psi4
import numpy as np

import sldf

psi4.set_memory('1000 MB')

mol = psi4.geometry('''
0 1
H    0.00000000    0.91087015    0.53855853
H    0.00000000   -0.88833620    0.55719192
O    0.00000000    0.00000000    1.29177249
symmetry c1
no_reorient
no_com
''')

psi4.set_options(
        {'basis': 'cc-pVTZ',
         'e_convergence': 1e-12,
         'dft_radial_points': 99,
         'dft_spherical_points': 590
         })

psi4.core.set_output_file('psi4.log')
e, wfn = psi4.energy('SCF', dft_functional='PBE', return_wfn=True)

D_psi4_mat = wfn.Da()
D = np.array(D_psi4_mat)

# Create a dummy superfunctional object to compute electron density 
# Set its potential based on previously calculated density matrix
# Must be a GGA or above which calculates density gradient
sup = psi4.driver.dft.build_superfunctional('PBE', True)[0]
Vpot = psi4.core.VBase.build(wfn.basisset(), sup, 'RV')
Vpot.initialize()
Vpot.set_D([D_psi4_mat])
Vpot.properties()[0].set_pointers(D_psi4_mat)

points_func = Vpot.properties()[0]

rho = []
dx_rho = []
dy_rho = []
dz_rho = []
weights = []
tau = []

# Reference: psi4numpy/Tutorials/04_Density_Functional_Theory/4c_GGA_and_Meta_GGA.ipynb
# Loop over the blocks
for i in range(Vpot.nblocks()):
    
    # Obtain block information
    block = Vpot.get_block(i)
    points_func.compute_points(block)
    npoints = block.npoints()
    lpos = np.array(block.functions_local_to_global())
    
    # Obtain the grid weight
    w_i = np.array(block.w())

    # Compute phi and derivatives
    phi = np.array(points_func.basis_values()["PHI"])[:npoints, :lpos.shape[0]]

    phi_x = np.array(points_func.basis_values()["PHI_X"])[:npoints, :lpos.shape[0]]
    phi_y = np.array(points_func.basis_values()["PHI_Y"])[:npoints, :lpos.shape[0]]
    phi_z = np.array(points_func.basis_values()["PHI_Z"])[:npoints, :lpos.shape[0]]
    
    # Build a local slice of D
    lD = D[(lpos[:, None], lpos)]
    
    # Copmute rho and derivatives
    rho_i = 2.0 * np.einsum('pm,mn,pn->p', phi, lD, phi, optimize=True)

    dx_rho_i = 4.0 * np.einsum('pm,mn,pn->p', phi, lD, phi_x, optimize=True)
    dy_rho_i = 4.0 * np.einsum('pm,mn,pn->p', phi, lD, phi_y, optimize=True)
    dz_rho_i = 4.0 * np.einsum('pm,mn,pn->p', phi, lD, phi_z, optimize=True)

    # Compute Tau
    tau_i = np.einsum('pm, mn, pn->p', phi_x,lD, phi_x, optimize=True)
    tau_i += np.einsum('pm, mn, pn->p', phi_y,lD, phi_y, optimize=True)
    tau_i += np.einsum('pm, mn, pn->p', phi_z,lD, phi_z, optimize=True)

    # Append
    weights.append(w_i)
    rho.append(rho_i) 
    dx_rho.append(dx_rho_i)
    dy_rho.append(dy_rho_i)
    dz_rho.append(dz_rho_i)
    tau.append(tau_i)

# Electron density and gradients
rho = np.concatenate(rho, axis=0)
dx_rho = np.concatenate(dx_rho, axis=0)
dy_rho = np.concatenate(dy_rho, axis=0)
dz_rho = np.concatenate(dz_rho, axis=0)

s = np.sqrt(dx_rho ** 2 + dy_rho ** 2 + dz_rho ** 2) / (rho ** (4/3))

# Grid weights
weights = np.concatenate(weights, axis=0)

# Kinetic energy density, tau;
# int tau dr = KE
tau = np.concatenate(tau, axis=0)

nsp = 20
sldf = sldf.calc_SLDF(rho, s, weights, nsp)

np.savetxt('sldf.csv', sldf)

print('SLDF is')
print(sldf)

Ex_sldf = np.sum(sldf[:nsp])
Ec_sldf = np.sum(sldf[nsp:])

# Reference SLDF is generated by Psi4 1.3.2;
# Might be slightly different if other versions of Psi4 are used
ref_sldf = np.array([
            -2.85475011e-02, -9.26264690e-01, -2.59304115e+00, -2.07919208e+00,
            -1.17329665e+00, -7.72350208e-01, -2.53682827e-01, -4.96976861e-02,
            -2.92283545e-02, -1.87682381e-02, -1.20938808e-02, -7.95307423e-03,
            -5.41378978e-03, -3.82040909e-03, -2.76662937e-03, -2.01155425e-03,
            -1.40458288e-03, -8.01537436e-04, -2.15886152e-04, -9.08855475e-06,
            -1.16044416e-06, -1.50259935e-05, -5.03609622e-05, -9.30375477e-05,
            -1.23151280e-04, -1.93404865e-04, -2.64170359e-04, -3.35808547e-04,
            -5.31230764e-04, -1.78871793e-03, -1.17599277e-02, -2.06781172e-02,
            -2.04437140e-02, -2.53034408e-02, -3.63062713e-02, -5.17657226e-02,
            -6.80585057e-02, -6.13488835e-02, -1.67550263e-02, -6.85708286e-04,
            -4.29842227e-04, -2.31815424e-02, -7.58482937e-02, -7.41305171e-02,
            -5.36720293e-02, -3.71238143e-02, -3.08188079e-02, -1.94276618e-02,
            -6.81343907e-03, -4.14983033e-03, -3.04577184e-03, -2.18772925e-03,
            -1.55166793e-03, -1.10970418e-03, -8.13477670e-04, -6.11721414e-04,
            -4.59070285e-04, -2.99037676e-04, -9.40416179e-05, -4.51254919e-06
           ])

if np.allclose(ref_sldf, sldf):
    print('SLDF generation is successful!')
    print('SLDF is saved to sldf.csv')
    print(f'Sum of Exchange SLDF = {Ex_sldf:.3f}')
    print(f'Sum of Correlation SLDF = {Ec_sldf:.3f}')
else:
    print('SLDF generation is not consistent with SLDF generated by Psi4 1.3.2')
    print(f'Mean absolute difference is {np.mean(abs(ref_sldf - sldf)):.2e}')
