import sys
import os
import psi4
import numpy as np

from sldf import calc_SLDF

psi4.set_memory('1000 MB')

mol = psi4.geometry('''
0 1
H    0.00000000    0.91087015    0.53855853
H    0.00000000   -0.88833620    0.55719192
O    0.00000000    0.00000000    1.29177249
symmetry c1
no_reorient
no_com
''')

psi4.set_options(
        {'basis': 'cc-pVTZ',
         'e_convergence': 1e-12,
         'dft_radial_points': 99,
         'dft_spherical_points': 590
         })

psi4.core.set_output_file('psi4.log')

# Create basis object
basis = psi4.core.BasisSet.build(mol, 'BASIS', psi4.core.get_global_option('BASIS'))

# Construct the SAD Guess for the initial density 
sad_basis_list = psi4.core.BasisSet.build(mol, 'BASIS',
    psi4.core.get_global_option('BASIS'), puream=basis.has_puream(),
                                     return_atomlist=True)
sad_fitting_list = psi4.core.BasisSet.build(mol, "DF_BASIS_SAD",
    psi4.core.get_option("SCF","DF_BASIS_SAD"), puream=basis.has_puream(),
                                       return_atomlist=True)

# Use Psi4 SADGuess object to build the SAD Guess
SAD = psi4.core.SADGuess.build_SAD(basis, sad_basis_list)
SAD.set_atomic_fit_bases(sad_fitting_list)
SAD.compute_guess()

D_psi4_mat = SAD.Da()
D = np.array(D_psi4_mat) 

# Create a superfunctional that computes electron density gradient
# Set its potential based on previously calculated density matrix
# Must be a GGA or above which calculates density gradient
sup = psi4.driver.dft.build_superfunctional('PBE', True)[0]
Vpot = psi4.core.VBase.build(basis, sup, 'RV')
Vpot.initialize()
Vpot.set_D([D_psi4_mat])
Vpot.properties()[0].set_pointers(D_psi4_mat)

points_func = Vpot.properties()[0]

rho = []
dx_rho = []
dy_rho = []
dz_rho = []
weights = []
tau = []

# Reference: psi4numpy/Tutorials/04_Density_Functional_Theory/4b_LDA_kernel.ipynb
# Loop over the blocks
for i in range(Vpot.nblocks()):
    
    # Obtain block information
    block = Vpot.get_block(i)
    points_func.compute_points(block)
    npoints = block.npoints()
    lpos = np.array(block.functions_local_to_global())
    
    # Obtain the grid weight
    w_i = np.array(block.w())

    # Compute phi and derivatives
    phi = np.array(points_func.basis_values()["PHI"])[:npoints, :lpos.shape[0]]

    phi_x = np.array(points_func.basis_values()["PHI_X"])[:npoints, :lpos.shape[0]]
    phi_y = np.array(points_func.basis_values()["PHI_Y"])[:npoints, :lpos.shape[0]]
    phi_z = np.array(points_func.basis_values()["PHI_Z"])[:npoints, :lpos.shape[0]]
    
    # Build a local slice of D
    lD = D[(lpos[:, None], lpos)]
    
    # Copmute rho and derivatives
    rho_i = 2.0 * np.einsum('pm,mn,pn->p', phi, lD, phi, optimize=True)

    dx_rho_i = 4.0 * np.einsum('pm,mn,pn->p', phi, lD, phi_x, optimize=True)
    dy_rho_i = 4.0 * np.einsum('pm,mn,pn->p', phi, lD, phi_y, optimize=True)
    dz_rho_i = 4.0 * np.einsum('pm,mn,pn->p', phi, lD, phi_z, optimize=True)

    # Compute Tau
    tau_i = np.einsum('pm, mn, pn->p', phi_x,lD, phi_x, optimize=True)
    tau_i += np.einsum('pm, mn, pn->p', phi_y,lD, phi_y, optimize=True)
    tau_i += np.einsum('pm, mn, pn->p', phi_z,lD, phi_z, optimize=True)

    # Append
    weights.append(w_i)
    rho.append(rho_i) 
    dx_rho.append(dx_rho_i)
    dy_rho.append(dy_rho_i)
    dz_rho.append(dz_rho_i)
    tau.append(tau_i)

# Electron density and gradients
rho = np.concatenate(rho, axis=0)
dx_rho = np.concatenate(dx_rho, axis=0)
dy_rho = np.concatenate(dy_rho, axis=0)
dz_rho = np.concatenate(dz_rho, axis=0)

s = np.sqrt(dx_rho ** 2 + dy_rho ** 2 + dz_rho ** 2) / (rho ** (4/3))

# Grid weights
weights = np.concatenate(weights, axis=0)

# Kinetic energy density, tau;
# int tau dr = KE
tau = np.concatenate(tau, axis=0)

nsp = 20
sldf = calc_SLDF(rho, s, weights, nsp)

np.savetxt('sldf.csv', sldf)

print('SLDF is')
print(sldf)

Ex_sldf = np.sum(sldf[:nsp])
Ec_sldf = np.sum(sldf[nsp:])

# Reference SLDF is generated by Psi4 1.3.2;
# Might be slightly different if other versions of Psi4 are used
ref_sldf = np.array([
-1.77824450e-02, -7.69849876e-01, -2.48829465e+00, -2.12436700e+00,
-1.17813311e+00, -7.89234249e-01, -2.35065910e-01, -3.83236587e-02,
-2.29913315e-02, -1.45458406e-02, -9.33746912e-03, -6.21315305e-03,
-4.29007591e-03, -3.03192173e-03, -2.16647142e-03, -1.52411929e-03,
-1.03111012e-03, -5.90289067e-04, -1.72196785e-04, -8.19211843e-06,
-3.07531555e-07, -5.23003795e-06, -1.84744082e-05, -3.12614997e-05,
-4.58897949e-05, -6.80937383e-05, -8.93043986e-05, -1.32749322e-04,
-1.89978958e-04, -2.88555003e-04, -4.49825334e-03, -1.82478775e-02,
-1.93776937e-02, -2.25150743e-02, -3.70286184e-02, -5.58307621e-02,
-7.22888171e-02, -6.17609550e-02, -1.54980842e-02, -5.80715763e-04,
-1.82402566e-04, -1.67644174e-02, -6.71363588e-02, -7.71746480e-02,
-5.78810918e-02, -3.85902759e-02, -3.19473729e-02, -1.96140378e-02,
-5.86980961e-03, -3.59103158e-03, -2.57474137e-03, -1.83610687e-03,
-1.31107053e-03, -9.50985217e-04, -7.04551639e-04, -5.20545768e-04,
-3.73911309e-04, -2.34121005e-04, -7.57462894e-05, -3.98817554e-06
])

if np.allclose(ref_sldf, sldf):
    print('SLDF generation is successful!')
    print('SLDF is saved to sldf.csv')
    print(f'Sum of Exchange SLDF = {Ex_sldf:.3f}')
    print(f'Sum of Correlation SLDF = {Ec_sldf:.3f}')
else:
    print('SLDF generation is not consistent with SLDF generated by Psi4 1.3.2')
    print(f'Mean absolute difference is {np.mean(abs(ref_sldf - sldf)):.2e}')

